// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

// =============== STRUCTS ===============

struct ShopItem {
    uint256 assetId;
    uint256 price;
    uint256 quantityAvailable;
    uint256 sold;
    uint256 startTime;
    uint256 endTime;
    bool active;
    uint256 maxPerWallet;
}

struct PurchaseRequest {
    uint256 assetId;
    uint256 quantity;
    bool useFree;
}

struct ShopItemView {
    uint256 assetId;
    uint256 price;
    uint256 quantityAvailable;
    uint256 sold;
    uint256 startTime;
    uint256 endTime;
    bool active;
    uint256 maxPerWallet;
    bool canPurchase;
    string purchaseError;
    bool hasAllowlist;
    uint256 freePerWallet;
    uint256 freeUsedByUser;
    uint256 freeRemaining;
    bool isAllowlisted;
}

// New structs to fix stack too deep
struct PurchaseValidation {
    bool canPurchase;
    string error;
    uint256 totalCost;
    uint256 userBalance;
    uint256 maxAllowed;
    uint256 freeAvailable;
}

struct BatchPreview {
    bool canPurchaseAll;
    uint256 totalCost;
    uint256 totalFreeAmount;
    string[] errors;
}

struct BatchPurchaseResult {
    uint256 totalCost;
    uint256 totalFreeAmount;
    uint256[] assetIds;
    uint256[] quantities;
}

// =============== INTERFACES ===============

interface IAdrianTraitsCore {
    function getAvailableSupply(uint256 assetId) external view returns (uint256);
    function balanceOf(address account, uint256 id) external view returns (uint256);
    function mintFromExtension(address to, uint256 id, uint256 amount) external;
    function burnFromExtension(address from, uint256 id, uint256 amount) external;
    function canEquipAsset(uint256 assetId) external view returns (bool);
    function getCategory(uint256 assetId) external view returns (string memory);
    function getCategoryList() external view returns (string[] memory);
    function treasuryWallet() external view returns (address);
    function authorizedExtensions(address extension) external view returns (bool);
    function getAssetData(uint256 assetId) external view returns (AssetData memory);
}

struct AssetData {
    string category;
    bool tempFlag;
    uint256 maxSupply;
    uint8 assetType;
}

contract AdrianSHOPv1 is Ownable, ReentrancyGuard {

    // =============== STATE VARIABLES ===============
    
    IAdrianTraitsCore public immutable traitsCore;
    IERC20 public immutable paymentToken;

    mapping(uint256 => ShopItem) public shopItems;
    mapping(address => mapping(uint256 => uint256)) public userPurchases;
    uint256[] public activeItemIds;
    mapping(uint256 => uint256) private activeItemIndex;

    mapping(uint256 => mapping(address => bool)) public allowlist;
    mapping(uint256 => mapping(address => uint256)) public freeUsed;
    mapping(uint256 => uint256) public freePerWallet;
    mapping(uint256 => bool) public hasAllowlist;

    bool public shopActive = true;
    uint256 public globalMaxPerTransaction = 50;
    address public treasuryOverride;

    uint256 public totalItemsSold;
    uint256 public totalRevenue;

    // =============== EVENTS ===============
    
    event ItemPurchased(
        address indexed buyer, 
        uint256 indexed assetId, 
        uint256 quantity, 
        uint256 unitPrice, 
        uint256 totalCost,
        uint256 freeAmount
    );

    event BatchPurchase(
        address indexed buyer, 
        uint256[] assetIds, 
        uint256[] quantities, 
        uint256 totalCost,
        uint256 totalFreeAmount
    );

    event FreeItemClaimed(
        address indexed user,
        uint256 indexed assetId,
        uint256 quantity
    );

    event ShopItemConfigured(
        uint256 indexed assetId, 
        uint256 price, 
        uint256 quantityAvailable, 
        bool active
    );

    event ShopItemTimingSet(
        uint256 indexed assetId,
        uint256 startTime,
        uint256 endTime
    );

    event ShopItemStatusChanged(uint256 indexed assetId, bool active);
    event ShopItemPriceChanged(uint256 indexed assetId, uint256 oldPrice, uint256 newPrice);
    event ShopItemQuantityUpdated(uint256 indexed assetId, uint256 newQuantity);

    event AllowlistConfigured(
        uint256 indexed assetId,
        uint256 freePerWallet,
        uint256 walletsCount
    );

    event WalletsAddedToAllowlist(uint256 indexed assetId, address[] wallets);
    event WalletsRemovedFromAllowlist(uint256 indexed assetId, address[] wallets);

    event ShopGlobalStatusChanged(bool active);
    event TreasuryOverrideSet(address newTreasury);

    // =============== CONSTRUCTOR ===============
    
    constructor(address _traitsCore, address _paymentToken) Ownable(msg.sender) {
        require(_traitsCore != address(0), "Invalid traits core");
        require(_paymentToken != address(0), "Invalid payment token");
        
        traitsCore = IAdrianTraitsCore(_traitsCore);
        paymentToken = IERC20(_paymentToken);
    }

    // =============== MODIFIERS ===============
    
    modifier shopIsActive() {
        require(shopActive, "Shop is paused");
        _;
    }

    modifier validAsset(uint256 assetId) {
        require(_isValidShopAsset(assetId), "Invalid asset");
        _;
    }

    // =============== SHOP CONFIGURATION ===============
    
    function setShopItem(
        uint256 assetId,
        uint256 price,
        uint256 quantityAvailable,
        uint256 startTime,
        uint256 endTime,
        bool active,
        uint256 maxPerWallet
    ) external onlyOwner {
        _setShopItemInternal(assetId, price, quantityAvailable, startTime, endTime, active, maxPerWallet);
    }

    // FIXED: Refactored to use struct for parameters
    struct BatchItemConfig {
        uint256 assetId;
        uint256 price;
        uint256 quantity;
        uint256 startTime;
        uint256 endTime;
        bool active;
        uint256 maxPerWallet;
    }

    function setMultipleShopItems(BatchItemConfig[] calldata configs) external onlyOwner {
        require(configs.length <= 20, "Too many items");

        for (uint256 i = 0; i < configs.length; i++) {
            BatchItemConfig calldata config = configs[i];
            _setShopItemInternal(
                config.assetId, 
                config.price, 
                config.quantity, 
                config.startTime, 
                config.endTime, 
                config.active, 
                config.maxPerWallet
            );
        }
    }

    function _setShopItemInternal(
        uint256 assetId,
        uint256 price,
        uint256 quantityAvailable,
        uint256 startTime,
        uint256 endTime,
        bool active,
        uint256 maxPerWallet
    ) internal {
        require(_isValidShopAsset(assetId), "Invalid asset");
        require(endTime == 0 || endTime > startTime, "Invalid timing");
        require(quantityAvailable > 0, "Invalid quantity");

        bool wasActive = shopItems[assetId].active;
        
        shopItems[assetId] = ShopItem({
            assetId: assetId,
            price: price,
            quantityAvailable: quantityAvailable,
            sold: shopItems[assetId].sold,
            startTime: startTime,
            endTime: endTime,
            active: active,
            maxPerWallet: maxPerWallet
        });

        if (active && !wasActive) {
            _addToActiveItems(assetId);
        } else if (!active && wasActive) {
            _removeFromActiveItems(assetId);
        }

        emit ShopItemConfigured(assetId, price, quantityAvailable, active);
        if (startTime > 0 || endTime > 0) {
            emit ShopItemTimingSet(assetId, startTime, endTime);
        }
    }

    // =============== QUICK UPDATE FUNCTIONS ===============
    
    function updateItemPrice(uint256 assetId, uint256 newPrice) external onlyOwner {
        require(shopItems[assetId].assetId != 0, "Item not configured");
        
        uint256 oldPrice = shopItems[assetId].price;
        shopItems[assetId].price = newPrice;
        
        emit ShopItemPriceChanged(assetId, oldPrice, newPrice);
    }

    function updateItemQuantity(uint256 assetId, uint256 newQuantity) external onlyOwner {
        require(shopItems[assetId].assetId != 0, "Item not configured");
        require(newQuantity >= shopItems[assetId].sold, "Quantity less than sold");
        
        shopItems[assetId].quantityAvailable = newQuantity;
        emit ShopItemQuantityUpdated(assetId, newQuantity);
    }

    function toggleItemStatus(uint256 assetId) external onlyOwner {
        require(shopItems[assetId].assetId != 0, "Item not configured");
        
        bool newStatus = !shopItems[assetId].active;
        shopItems[assetId].active = newStatus;
        
        if (newStatus) {
            _addToActiveItems(assetId);
        } else {
            _removeFromActiveItems(assetId);
        }
        
        emit ShopItemStatusChanged(assetId, newStatus);
    }

    function updateItemTiming(uint256 assetId, uint256 startTime, uint256 endTime) external onlyOwner {
        require(shopItems[assetId].assetId != 0, "Item not configured");
        require(endTime == 0 || endTime > startTime, "Invalid timing");
        
        shopItems[assetId].startTime = startTime;
        shopItems[assetId].endTime = endTime;
    }

    // =============== ALLOWLIST SYSTEM ===============
    
    function setItemAllowlist(
        uint256 assetId,
        uint256 freeQuantityPerWallet,
        address[] calldata wallets
    ) external onlyOwner {
        require(shopItems[assetId].assetId != 0, "Item not configured");
        require(wallets.length > 0, "Empty wallets array");
        require(wallets.length <= 500, "Too many wallets");
        
        hasAllowlist[assetId] = true;
        freePerWallet[assetId] = freeQuantityPerWallet;
        
        _addMultipleToAllowlist(assetId, wallets);
        
        emit AllowlistConfigured(assetId, freeQuantityPerWallet, wallets.length);
    }

    function addWalletsToAllowlist(uint256 assetId, address[] calldata wallets) external onlyOwner {
        require(hasAllowlist[assetId], "Item has no allowlist");
        require(wallets.length > 0, "Empty wallets array");
        require(wallets.length <= 100, "Too many wallets");
        
        _addMultipleToAllowlist(assetId, wallets);
        emit WalletsAddedToAllowlist(assetId, wallets);
    }

    function removeWalletsFromAllowlist(uint256 assetId, address[] calldata wallets) external onlyOwner {
        require(hasAllowlist[assetId], "Item has no allowlist");
        require(wallets.length > 0, "Empty wallets array");
        
        _removeMultipleFromAllowlist(assetId, wallets);
        emit WalletsRemovedFromAllowlist(assetId, wallets);
    }

    function clearItemAllowlist(uint256 assetId) external onlyOwner {
        require(shopItems[assetId].assetId != 0, "Item not configured");
        
        hasAllowlist[assetId] = false;
        freePerWallet[assetId] = 0;
        
        emit AllowlistConfigured(assetId, 0, 0);
    }

    // =============== PURCHASE SYSTEM ===============
    
    function purchaseItem(uint256 assetId, uint256 quantity, bool useFree) external nonReentrant shopIsActive {
        require(quantity > 0, "Invalid quantity");
        require(quantity <= globalMaxPerTransaction, "Exceeds global limit");
        
        (bool valid, string memory error) = _validatePurchase(msg.sender, assetId, quantity, useFree);
        require(valid, error);
        
        (uint256 totalCost, uint256 freeAmount) = _processPurchase(msg.sender, assetId, quantity, useFree);
        
        emit ItemPurchased(msg.sender, assetId, quantity, shopItems[assetId].price, totalCost, freeAmount);
    }

    // FIXED: Using struct for batch results
    function batchPurchase(PurchaseRequest[] calldata requests) external nonReentrant shopIsActive {
        require(requests.length > 0, "Empty requests");
        require(requests.length <= 10, "Too many requests");
        
        _validateBatchRequests(requests);
        
        BatchPurchaseResult memory result = _processBatchPurchases(requests);
        
        emit BatchPurchase(msg.sender, result.assetIds, result.quantities, result.totalCost, result.totalFreeAmount);
    }

    function _validateBatchRequests(PurchaseRequest[] calldata requests) internal view {
        for (uint256 i = 0; i < requests.length; i++) {
            require(requests[i].quantity > 0, "Invalid quantity");
            (bool valid, string memory error) = _validatePurchase(msg.sender, requests[i].assetId, requests[i].quantity, requests[i].useFree);
            require(valid, error);
        }
    }

    // FIXED: Using struct for return values
    function _processBatchPurchases(PurchaseRequest[] calldata requests) internal returns (BatchPurchaseResult memory result) {
        result.assetIds = new uint256[](requests.length);
        result.quantities = new uint256[](requests.length);
        
        for (uint256 i = 0; i < requests.length; i++) {
            _processSingleBatchItem(requests[i], result, i);
        }
        
        return result;
    }

    function _processSingleBatchItem(
        PurchaseRequest calldata request,
        BatchPurchaseResult memory result,
        uint256 index
    ) internal {
        (uint256 itemCost, uint256 itemFreeAmount) = _processPurchase(
            msg.sender, 
            request.assetId, 
            request.quantity, 
            request.useFree
        );
        
        result.totalCost += itemCost;
        result.totalFreeAmount += itemFreeAmount;
        result.assetIds[index] = request.assetId;
        result.quantities[index] = request.quantity;
    }

    function claimFreeItem(uint256 assetId, uint256 quantity) external nonReentrant shopIsActive {
        require(quantity > 0, "Invalid quantity");
        require(hasAllowlist[assetId], "No allowlist");
        require(allowlist[assetId][msg.sender], "Not allowlisted");
        
        (bool valid, string memory error) = _validatePurchase(msg.sender, assetId, quantity, true);
        require(valid, error);
        
        // Fixed: Don't capture totalCost since we're not using it
        (, uint256 freeAmount) = _processPurchase(msg.sender, assetId, quantity, true);
        
        emit FreeItemClaimed(msg.sender, assetId, freeAmount);
    }

    // =============== INTERNAL PURCHASE LOGIC ===============
    
    function _processPurchase(address buyer, uint256 assetId, uint256 quantity, bool useFree) internal returns (uint256 totalCost, uint256 freeAmount) {
        ShopItem storage item = shopItems[assetId];
        
        if (useFree && hasAllowlist[assetId] && allowlist[assetId][buyer]) {
            (freeAmount, quantity) = _processFreeAllocation(buyer, assetId, quantity);
        }
        
        totalCost = quantity * item.price;
        
        if (totalCost > 0) {
            require(
                paymentToken.transferFrom(buyer, _getEffectiveTreasury(), totalCost),
                "Payment failed"
            );
        }
        
        uint256 totalQuantity = quantity + freeAmount;
        item.sold += totalQuantity;
        userPurchases[buyer][assetId] += totalQuantity;
        totalItemsSold += totalQuantity;
        totalRevenue += totalCost;
        
        traitsCore.mintFromExtension(buyer, assetId, totalQuantity);
        
        return (totalCost, freeAmount);
    }

    function _processFreeAllocation(address buyer, uint256 assetId, uint256 requestedQuantity) internal returns (uint256 freeToUse, uint256 remainingPaid) {
        uint256 freeRemaining = _getFreeRemaining(assetId, buyer);
        
        freeToUse = requestedQuantity > freeRemaining ? freeRemaining : requestedQuantity;
        remainingPaid = requestedQuantity - freeToUse;
        
        if (freeToUse > 0) {
            freeUsed[assetId][buyer] += freeToUse;
        }
        
        return (freeToUse, remainingPaid);
    }

    function _validatePurchase(address buyer, uint256 assetId, uint256 quantity, bool useFree) internal view returns (bool valid, string memory error) {
        ShopItem storage item = shopItems[assetId];
        
        if (item.assetId == 0) return (false, "Item not configured");
        if (!item.active) return (false, "Item not active");
        if (!_isWithinTimeWindow(assetId)) return (false, "Outside time window");
        if (item.sold + quantity > item.quantityAvailable) return (false, "Insufficient quantity");
        
        if (_getAvailableSupplySafe(assetId) < quantity) return (false, "TraitsCore supply exceeded");
        
        if (item.maxPerWallet > 0) {
            if (userPurchases[buyer][assetId] + quantity > item.maxPerWallet) return (false, "Exceeds wallet limit");
        }
        
        if (useFree) {
            return _validateFreeAllocation(buyer, assetId, quantity);
        }
        
        return _validatePayment(buyer, assetId, quantity);
    }

    function _validateFreeAllocation(address buyer, uint256 assetId, uint256 quantity) internal view returns (bool valid, string memory error) {
        if (!hasAllowlist[assetId]) return (false, "No allowlist");
        if (!allowlist[assetId][buyer]) return (false, "Not allowlisted");
        
        uint256 freeRemaining = _getFreeRemaining(assetId, buyer);
        if (freeRemaining == 0) return (false, "No free allocation remaining");
        
        // Fixed: Actually validate the quantity against free remaining
        if (quantity > freeRemaining) return (false, "Exceeds free allocation");
        
        return (true, "");
    }

    function _validatePayment(address buyer, uint256 assetId, uint256 quantity) internal view returns (bool valid, string memory error) {
        ShopItem storage item = shopItems[assetId];
        if (item.price > 0) {
            if (paymentToken.balanceOf(buyer) < quantity * item.price) return (false, "Insufficient balance");
        }
        return (true, "");
    }

    // =============== VIEW FUNCTIONS ===============
    
    function getActiveItems(uint256 offset, uint256 limit) external view returns (ShopItemView[] memory items, uint256 totalActive) {
        totalActive = activeItemIds.length;
        
        if (offset >= totalActive) {
            return (new ShopItemView[](0), totalActive);
        }
        
        uint256 length = _calculateItemsLength(offset, limit, totalActive);
        items = _buildActiveItems(offset, length);
        
        return (items, totalActive);
    }

    function _calculateItemsLength(uint256 offset, uint256 limit, uint256 totalActive) internal pure returns (uint256) {
        uint256 end = offset + limit;
        if (end > totalActive) {
            end = totalActive;
        }
        return end - offset;
    }

    function _buildActiveItems(uint256 offset, uint256 length) internal view returns (ShopItemView[] memory items) {
        items = new ShopItemView[](length);
        
        for (uint256 i = 0; i < length; i++) {
            uint256 assetId = activeItemIds[offset + i];
            items[i] = getShopItemView(assetId, msg.sender);
        }
        
        return items;
    }

    function getShopItemView(uint256 assetId, address user) public view returns (ShopItemView memory) {
        ShopItem storage item = shopItems[assetId];
        
        if (item.assetId == 0) {
            return _createEmptyItemView(assetId);
        }
        
        (bool canPurchase, string memory error) = _validatePurchase(user, assetId, 1, false);
        
        return _createItemView(item, assetId, user, canPurchase, error);
    }

    function _createEmptyItemView(uint256 assetId) internal pure returns (ShopItemView memory) {
        return ShopItemView({
            assetId: assetId,
            price: 0,
            quantityAvailable: 0,
            sold: 0,
            startTime: 0,
            endTime: 0,
            active: false,
            maxPerWallet: 0,
            canPurchase: false,
            purchaseError: "Item not configured",
            hasAllowlist: false,
            freePerWallet: 0,
            freeUsedByUser: 0,
            freeRemaining: 0,
            isAllowlisted: false
        });
    }

    // FIXED: Split into smaller functions
    function _createItemView(
        ShopItem storage item, 
        uint256 assetId, 
        address user, 
        bool canPurchase, 
        string memory error
    ) internal view returns (ShopItemView memory itemView) {
        _setBasicItemData(itemView, item, assetId);
        _setPurchaseData(itemView, canPurchase, error, item.maxPerWallet);
        _setAllowlistData(itemView, assetId, user);
        
        return itemView;
    }

    function _setBasicItemData(
        ShopItemView memory itemView,
        ShopItem storage item,
        uint256 assetId
    ) internal view {
        itemView.assetId = assetId;
        itemView.price = item.price;
        itemView.quantityAvailable = item.quantityAvailable;
        itemView.sold = item.sold;
        itemView.startTime = item.startTime;
        itemView.endTime = item.endTime;
        itemView.active = item.active;
    }

    function _setPurchaseData(
        ShopItemView memory itemView,
        bool canPurchase,
        string memory error,
        uint256 maxPerWallet
    ) internal pure {
        itemView.canPurchase = canPurchase;
        itemView.purchaseError = error;
        itemView.maxPerWallet = maxPerWallet;
    }

    function _setAllowlistData(
        ShopItemView memory itemView,
        uint256 assetId,
        address user
    ) internal view {
        itemView.hasAllowlist = hasAllowlist[assetId];
        itemView.freePerWallet = freePerWallet[assetId];
        itemView.freeUsedByUser = freeUsed[assetId][user];
        itemView.freeRemaining = _getFreeRemaining(assetId, user);
        itemView.isAllowlisted = allowlist[assetId][user];
    }

    function batchGetShopItems(uint256[] calldata assetIds, address user) external view returns (ShopItemView[] memory) {
        ShopItemView[] memory items = new ShopItemView[](assetIds.length);
        
        for (uint256 i = 0; i < assetIds.length; i++) {
            items[i] = getShopItemView(assetIds[i], user);
        }
        
        return items;
    }

    function getItemsByCategory(string calldata category, address user) external view returns (ShopItemView[] memory) {
        uint256 count = _countItemsByCategory(category);
        
        if (count == 0) {
            return new ShopItemView[](0);
        }
        
        return _buildCategoryItems(category, user, count);
    }

    function _countItemsByCategory(string calldata category) internal view returns (uint256 count) {
        bytes32 categoryHash = keccak256(bytes(category));
        
        for (uint256 i = 0; i < activeItemIds.length; i++) {
            if (_itemMatchesCategory(activeItemIds[i], categoryHash)) {
                count++;
            }
        }
        return count;
    }

    function _buildCategoryItems(string calldata category, address user, uint256 count) internal view returns (ShopItemView[] memory items) {
        items = new ShopItemView[](count);
        bytes32 categoryHash = keccak256(bytes(category));
        uint256 index = 0;
        
        for (uint256 i = 0; i < activeItemIds.length && index < count; i++) {
            uint256 assetId = activeItemIds[i];
            if (_itemMatchesCategory(assetId, categoryHash)) {
                items[index] = getShopItemView(assetId, user);
                index++;
            }
        }
        
        return items;
    }

    function _itemMatchesCategory(uint256 assetId, bytes32 categoryHash) internal view returns (bool) {
        try traitsCore.getCategory(assetId) returns (string memory itemCategory) {
            return keccak256(bytes(itemCategory)) == categoryHash;
        } catch {
            return false;
        }
    }

    // FIXED: Using struct for return values
    function canPurchaseItem(
        address user, 
        uint256 assetId, 
        uint256 quantity, 
        bool useFree
    ) external view returns (PurchaseValidation memory validation) {
        (validation.canPurchase, validation.error) = _validatePurchase(user, assetId, quantity, useFree);
        
        validation.userBalance = paymentToken.balanceOf(user);
        validation.freeAvailable = _getFreeRemaining(assetId, user);
        validation.totalCost = _calculateTotalCost(user, assetId, quantity, useFree);
        validation.maxAllowed = _calculateMaxAllowed(user, assetId);
        
        return validation;
    }

    function _calculateTotalCost(address user, uint256 assetId, uint256 quantity, bool useFree) internal view returns (uint256) {
        ShopItem storage item = shopItems[assetId];
        
        uint256 freeToUse = 0;
        if (useFree && hasAllowlist[assetId] && allowlist[assetId][user]) {
            uint256 freeRemaining = _getFreeRemaining(assetId, user);
            freeToUse = quantity > freeRemaining ? freeRemaining : quantity;
        }
        
        return (quantity - freeToUse) * item.price;
    }

    function _calculateMaxAllowed(address user, uint256 assetId) internal view returns (uint256) {
        ShopItem storage item = shopItems[assetId];
        
        uint256 maxAllowed = item.quantityAvailable - item.sold;
        
        if (item.maxPerWallet > 0) {
            uint256 userRemaining = item.maxPerWallet - userPurchases[user][assetId];
            if (userRemaining < maxAllowed) {
                maxAllowed = userRemaining;
            }
        }
        
        uint256 coreAvailable = _getAvailableSupplySafe(assetId);
        if (coreAvailable < maxAllowed) {
            maxAllowed = coreAvailable;
        }
        
        return maxAllowed;
    }

    // FIXED: Using struct for return values
    function previewBatchPurchase(
        PurchaseRequest[] calldata requests, 
        address user
    ) external view returns (BatchPreview memory preview) {
        preview.canPurchaseAll = true;
        preview.errors = new string[](requests.length);
        
        for (uint256 i = 0; i < requests.length; i++) {
            _processBatchValidation(requests[i], user, preview, i);
            
            if (bytes(preview.errors[i]).length == 0) {
                _addBatchCosts(requests[i], user, preview);
            }
        }
        
        return preview;
    }

    function _processBatchValidation(
        PurchaseRequest memory req,
        address user,
        BatchPreview memory preview,
        uint256 index
    ) internal view {
        (bool valid, string memory error) = _validatePurchase(user, req.assetId, req.quantity, req.useFree);
        preview.errors[index] = error;
        
        if (!valid) {
            preview.canPurchaseAll = false;
        }
    }

    function _addBatchCosts(
        PurchaseRequest memory req,
        address user,
        BatchPreview memory preview
    ) internal view {
        (uint256 requestCost, uint256 requestFree) = _calculateRequestCost(user, req);
        preview.totalCost += requestCost;
        preview.totalFreeAmount += requestFree;
    }

    function _calculateRequestCost(address user, PurchaseRequest memory req) internal view returns (uint256 cost, uint256 freeAmount) {
        ShopItem storage item = shopItems[req.assetId];
        
        if (req.useFree && hasAllowlist[req.assetId] && allowlist[req.assetId][user]) {
            uint256 freeRemaining = _getFreeRemaining(req.assetId, user);
            freeAmount = req.quantity > freeRemaining ? freeRemaining : req.quantity;
        }
        
        cost = (req.quantity - freeAmount) * item.price;
        return (cost, freeAmount);
    }

    // =============== ALLOWLIST VIEW FUNCTIONS ===============
    
    function getUserAllowlistStatus(address user, uint256 assetId) external view returns (
        bool isAllowlisted,
        uint256 freePerWalletAmount,
        uint256 freeUsedAmount,
        uint256 freeRemainingAmount
    ) {
        isAllowlisted = allowlist[assetId][user];
        freePerWalletAmount = freePerWallet[assetId];
        freeUsedAmount = freeUsed[assetId][user];
        freeRemainingAmount = _getFreeRemaining(assetId, user);
        
        return (isAllowlisted, freePerWalletAmount, freeUsedAmount, freeRemainingAmount);
    }

    function getItemAllowlistInfo(uint256 assetId) external view returns (
        bool hasAllowlistEnabled,
        uint256 freePerWalletAmount,
        uint256 totalAllowlisted
    ) {
        hasAllowlistEnabled = hasAllowlist[assetId];
        freePerWalletAmount = freePerWallet[assetId];
        totalAllowlisted = 0;
        
        return (hasAllowlistEnabled, freePerWalletAmount, totalAllowlisted);
    }

    function isWalletAllowlisted(uint256 assetId, address wallet) external view returns (bool) {
        return allowlist[assetId][wallet];
    }

    // =============== STATS & ANALYTICS ===============
    
    function getShopStats() external view returns (
        uint256 totalActiveItems,
        uint256 totalItemsSoldAmount,
        uint256 totalRevenueAmount
    ) {
        return (activeItemIds.length, totalItemsSold, totalRevenue);
    }

    function getUserPurchaseHistory(address user, uint256 offset, uint256 limit) external view returns (
        uint256[] memory assetIds,
        uint256[] memory quantities
    ) {
        uint256 count = _countUserPurchases(user);
        
        if (offset >= count) {
            return (new uint256[](0), new uint256[](0));
        }
        
        uint256 end = offset + limit;
        if (end > count) {
            end = count;
        }
        
        uint256 length = end - offset;
        return _buildPurchaseHistory(user, offset, length);
    }

    function _countUserPurchases(address user) internal view returns (uint256 count) {
        for (uint256 i = 0; i < activeItemIds.length; i++) {
            if (userPurchases[user][activeItemIds[i]] > 0) {
                count++;
            }
        }
        return count;
    }

    function _buildPurchaseHistory(address user, uint256 offset, uint256 length) internal view returns (
        uint256[] memory assetIds,
        uint256[] memory quantities
    ) {
        assetIds = new uint256[](length);
        quantities = new uint256[](length);
        
        uint256 found = 0;
        uint256 index = 0;
        
        for (uint256 i = 0; i < activeItemIds.length && index < length; i++) {
            uint256 assetId = activeItemIds[i];
            uint256 userQuantity = userPurchases[user][assetId];
            
            if (userQuantity > 0) {
                if (found >= offset) {
                    assetIds[index] = assetId;
                    quantities[index] = userQuantity;
                    index++;
                }
                found++;
            }
        }
        
        return (assetIds, quantities);
    }

    // =============== ADMIN FUNCTIONS ===============
    
    function setShopStatus(bool active) external onlyOwner {
        shopActive = active;
        emit ShopGlobalStatusChanged(active);
    }

    function setTreasuryOverride(address newTreasury) external onlyOwner {
        treasuryOverride = newTreasury;
        emit TreasuryOverrideSet(newTreasury);
    }

    function setGlobalMaxPerTransaction(uint256 maxAmount) external onlyOwner {
        require(maxAmount > 0 && maxAmount <= 100, "Invalid max amount");
        globalMaxPerTransaction = maxAmount;
    }

    function emergencyWithdraw(address token, uint256 amount) external onlyOwner {
        if (token == address(0)) {
            payable(owner()).transfer(amount);
        } else {
            IERC20(token).transfer(owner(), amount);
        }
    }

    function removeMultipleItems(uint256[] calldata assetIds) external onlyOwner {
        for (uint256 i = 0; i < assetIds.length; i++) {
            if (shopItems[assetIds[i]].active) {
                shopItems[assetIds[i]].active = false;
                _removeFromActiveItems(assetIds[i]);
                emit ShopItemStatusChanged(assetIds[i], false);
            }
        }
    }

    // =============== INTERNAL HELPERS ===============
    
    function _addToActiveItems(uint256 assetId) internal {
        if (activeItemIndex[assetId] == 0 && (activeItemIds.length == 0 || activeItemIds[0] != assetId)) {
            activeItemIds.push(assetId);
            activeItemIndex[assetId] = activeItemIds.length;
        }
    }

    function _removeFromActiveItems(uint256 assetId) internal {
        uint256 index = activeItemIndex[assetId];
        if (index > 0) {
            uint256 lastIndex = activeItemIds.length - 1;
            uint256 lastAssetId = activeItemIds[lastIndex];
            
            activeItemIds[index - 1] = lastAssetId;
            activeItemIndex[lastAssetId] = index;
            
            activeItemIds.pop();
            delete activeItemIndex[assetId];
        } else if (activeItemIds.length > 0 && activeItemIds[0] == assetId) {
            uint256 lastIndex = activeItemIds.length - 1;
            if (lastIndex > 0) {
                uint256 lastAssetId = activeItemIds[lastIndex];
                activeItemIds[0] = lastAssetId;
                activeItemIndex[lastAssetId] = 1;
            }
            activeItemIds.pop();
            delete activeItemIndex[assetId];
        }
    }

    function _addMultipleToAllowlist(uint256 assetId, address[] calldata wallets) internal {
        for (uint256 i = 0; i < wallets.length; i++) {
            require(wallets[i] != address(0), "Invalid wallet");
            allowlist[assetId][wallets[i]] = true;
        }
    }

    function _removeMultipleFromAllowlist(uint256 assetId, address[] calldata wallets) internal {
        for (uint256 i = 0; i < wallets.length; i++) {
            allowlist[assetId][wallets[i]] = false;
        }
    }

    function _isValidShopAsset(uint256 assetId) internal view returns (bool) {
        try traitsCore.getAssetData(assetId) returns (AssetData memory asset) {
            return asset.maxSupply > 0;
        } catch {
            return false;
        }
    }

    function _getEffectiveTreasury() internal view returns (address) {
        return treasuryOverride != address(0) ? treasuryOverride : traitsCore.treasuryWallet();
    }

    function _isWithinTimeWindow(uint256 assetId) internal view returns (bool) {
        ShopItem storage item = shopItems[assetId];
        
        if (item.startTime > 0 && block.timestamp < item.startTime) {
            return false;
        }
        
        if (item.endTime > 0 && block.timestamp > item.endTime) {
            return false;
        }
        
        return true;
    }

    function _getFreeRemaining(uint256 assetId, address user) internal view returns (uint256) {
        if (!hasAllowlist[assetId] || !allowlist[assetId][user]) {
            return 0;
        }
        
        uint256 used = freeUsed[assetId][user];
        uint256 allowed = freePerWallet[assetId];
        return allowed > used ? allowed - used : 0;
    }

    function _getAvailableSupplySafe(uint256 assetId) internal view returns (uint256) {
        try traitsCore.getAvailableSupply(assetId) returns (uint256 available) {
            return available;
        } catch {
            return 0;
        }
    }

    function getActiveItemsCount() external view returns (uint256) {
        return activeItemIds.length;
    }

    function getActiveItemIds() external view returns (uint256[] memory) {
        return activeItemIds;
    }
}